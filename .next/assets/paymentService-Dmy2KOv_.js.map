{"version":3,"file":"paymentService-Dmy2KOv_.js","sources":["../../src/services/notifications.ts","../../src/services/paymentService.ts"],"sourcesContent":["import { supabase } from '../lib/supabase';\n\nexport const notificationsService = {\n    async sendNotification(userId: string, message: string, type: 'payment' | 'payout') {\n        try {\n            const { error } = await supabase\n                .from('notifications')\n                .insert({\n                    user_id: userId,\n                    message,\n                    type,\n                    read: false\n                });\n            if (error) throw error;\n            return { success: true };\n        } catch (error) {\n            console.error('Error sending notification:', error);\n            throw error;\n        }\n    }\n}; ","import { supabase } from '../lib/supabase';\nimport { notificationsService } from './notifications.ts';\nimport { Payment } from '../types/database';\n\ninterface ContractWithClient {\n  id: string;\n  client_id: string;\n  freelancer_id: string;\n  title: string;\n  client_profiles: Array<{\n    email: string;\n    phone: string | null;\n  }>;\n}\n\ninterface PaymentWithContract extends Payment {\n  contract: ContractWithClient;\n}\n\ninterface PaymentHistoryItem {\n  id: string;\n  amount: number;\n  status: string;\n  payment_type: string;\n  created_at: string;\n  contract: {\n    title: string;\n    client: {\n      company_name: string;\n    };\n    freelancer: {\n      full_name: string;\n    };\n  };\n}\n\nconst paymentService = {\n    // Create a new payment for a project\n    async createPayment(contractId: string, amount: number, paymentType: 'milestone' | 'completion') {\n        console.log('[paymentService] 1. Starting createPayment with:', { contractId, amount, paymentType });\n        let paymentLink: string;\n        \n        try {\n            const isDev = import.meta.env.DEV;\n            console.log('[paymentService] 2. Environment check - isDev:', isDev);\n            \n            // Always use a relative URL to avoid CORS issues\n            const apiUrl = '/api/payments';\n            console.log('[paymentService] Using API URL:', apiUrl);\n                \n            console.log('[paymentService] 3. Preparing to make request to:', apiUrl);\n            \n            const requestBody = {\n                contractId,\n                amount: Number(amount),\n                paymentType,\n            };\n            \n            console.log('[paymentService] 4. Request payload:', JSON.stringify(requestBody, null, 2));\n            \n            const startTime = Date.now();\n            console.log('[paymentService] 5. Making fetch request at:', new Date().toISOString());\n            console.log('[paymentService] 5.1 Request URL:', apiUrl);\n            \n            try {\n                const response = await fetch(apiUrl, {\n                    method: 'POST',\n                    // Don't specify mode to let browser handle it\n                    headers: {\n                        'Content-Type': 'application/json',\n                        'Accept': 'application/json'\n                    },\n                    body: JSON.stringify({\n                        contractId,\n                        amount: Number(amount),\n                        paymentType,\n                    }),\n                    // Use same-origin for credentials to avoid CORS preflight issues\n                    credentials: 'same-origin'\n                });\n\n                if (!response.ok) {\n                    let errorMessage = `HTTP error! status: ${response.status}`;\n                    try {\n                        const errorData = await response.json();\n                        errorMessage = errorData.message || errorData.error || JSON.stringify(errorData);\n                    } catch (e) {\n                        // If we can't parse the error as JSON, use the status text\n                        const text = await response.text();\n                        errorMessage = text || response.statusText || `HTTP error! status: ${response.status}`;\n                    }\n                    console.error('[paymentService] Server responded with error:', {\n                        status: response.status,\n                        statusText: response.statusText,\n                        url: response.url,\n                        error: errorMessage\n                    });\n                    throw new Error(errorMessage);\n                }\n\n                const responseData = await response.json();\n                \n                if (!responseData.link && !responseData.payment_link && !responseData.paymentLink) {\n                    throw new Error('No payment link received from server');\n                }\n                \n                console.log('[paymentService] 5.2 Fetch completed, status:', response.status);\n                console.log('[paymentService] 5.4 Payment created successfully:', responseData);\n                \n                const { payment_link, paymentLink } = responseData;\n                const link = responseData.link || payment_link || paymentLink;\n                if (!link) {\n                    throw new Error('No payment link received from the server');\n                }\n                return link;\n                \n            } catch (error) {\n                console.error('[paymentService] 5.5 Fetch error:', error);\n                if (error instanceof TypeError) {\n                    console.error('[paymentService] 5.6 This is likely a CORS or network issue. Check if the backend server is running and accessible.');\n                    console.error('[paymentService] 5.7 Try accessing this URL directly in your browser:', apiUrl);\n                } else if (error instanceof Error) {\n                    // If it's an Error object, include the stack trace\n                    console.error('[paymentService] Error stack:', error.stack);\n                }\n                // Re-throw with more context\n                const errorMessage = error instanceof Error ? error.message : 'Unknown error occurred';\n                throw new Error(`Payment creation failed: ${errorMessage}`);\n            }\n            \n            // Get contract for notifications\n            const { data: contract, error: contractError } = await supabase\n                .from('contracts')\n                .select('id, client_id, freelancer_id, title')\n                .eq('id', contractId)\n                .single();\n\n            if (contractError) {\n                console.error('Error fetching contract:', contractError);\n                throw new Error('Failed to fetch contract details');\n            }\n\n            if (!contract) {\n                throw new Error('Contract not found');\n            }\n            // Type assertion to ensure TypeScript knows contract is not null\n            const validContract = contract as ContractWithClient;\n            \n            // Send notifications\n            try {\n                await notificationsService.sendNotification(\n                    validContract.client_id,\n                    `Payment request of $${amount} for contract \"${validContract.title}\"`,\n                    'payment'\n                );\n\n                await notificationsService.sendNotification(\n                    validContract.freelancer_id,\n                    `Payment request of $${amount} has been sent to the client for contract \"${validContract.title}\"`,\n                    'payment'\n                );\n            } catch (error) {\n                console.error('Error sending notifications:', error);\n                // Don't fail the payment if notifications fail\n            }\n            \n            return paymentLink;\n        } catch (error) {\n            console.error('Error in createPayment:', error);\n            throw error;\n        }\n    },\n\n    // Handle payment success\n    async handlePaymentSuccess(paymentId: string, cashfreePaymentId: string) {\n        const { data: payment, error: fetchError } = await supabase\n            .from('payments')\n            .select('*, contract:contracts!inner(id, freelancer_id, client_id, title, status)')\n            .eq('id', paymentId)\n            .single();\n\n        if (fetchError || !payment) {\n            console.error('Error fetching payment:', fetchError);\n            throw new Error('Payment not found or access denied');\n        }\n\n        // Update payment status\n        const { error: updateError } = await supabase\n            .from('payments')\n            .update({\n                status: 'paid',\n                cashfree_payment_id: cashfreePaymentId,\n                paid_at: new Date().toISOString()\n            })\n            .eq('id', paymentId);\n\n        if (updateError) throw updateError;\n\n        // Calculate platform fee and freelancer amount (10% platform fee)\n        const platformFee = payment.amount * 0.1;\n        const freelancerAmount = payment.amount - platformFee;\n\n        // Update or create freelancer wallet\n        const { data: wallet, error: walletFetchError } = await supabase\n            .from('freelancer_wallets')\n            .select('available_balance, total_earned')\n            .eq('freelancer_id', payment.contract.freelancer_id)\n            .single();\n\n        if (walletFetchError && walletFetchError.code !== 'PGRST116') { // Ignore not found error\n            console.error('Error fetching wallet:', walletFetchError);\n            throw walletFetchError;\n        }\n\n        const newBalance = (wallet?.available_balance || 0) + freelancerAmount;\n        const totalEarned = (wallet?.total_earned || 0) + freelancerAmount;\n\n        const { error: walletUpdateError } = await supabase\n            .from('freelancer_wallets')\n            .upsert({\n                freelancer_id: payment.contract.freelancer_id,\n                available_balance: newBalance,\n                total_earned: totalEarned\n            }, {\n                onConflict: 'freelancer_id'\n            });\n\n        if (walletUpdateError) {\n            console.error('Error updating wallet:', walletUpdateError);\n            throw walletUpdateError;\n        }\n\n        // Send notifications\n        await notificationsService.sendNotification(\n            payment.contract.freelancer_id,\n            `Payment of $${payment.amount.toFixed(2)} received. Your wallet has been credited with $${freelancerAmount.toFixed(2)}.`,\n            'payment'\n        );\n\n        await notificationsService.sendNotification(\n            payment.contract.client_id,\n            `Payment of $${payment.amount.toFixed(2)} has been processed successfully.`,\n            'payment'\n        );\n\n        // Update contract status if it's a completion payment\n        if (payment.payment_type === 'completion') {\n            const { error: contractError } = await supabase\n                .from('contracts')\n                .update({ \n                    status: 'completed',\n                    completed_at: new Date().toISOString()\n                })\n                .eq('id', payment.contract_id);\n\n            if (contractError) {\n                console.error('Error updating contract status:', contractError);\n                throw contractError;\n            }\n        }\n    },\n\n    // Request payout\n    async requestPayout(userId: string, amount: number, bankDetails: { accountNumber: string; ifscCode: string }) {\n        // Check if user has sufficient balance\n        const { data: wallet, error: walletError } = await supabase\n            .from('freelancer_wallets')\n            .select('available_balance')\n            .eq('freelancer_id', userId)\n            .single();\n\n        if (walletError) throw walletError;\n        if (!wallet || wallet.available_balance < amount) {\n            throw new Error('Insufficient balance for this payout request.');\n        }\n\n        // Create payout request\n        const { data: payout, error: payoutError } = await supabase\n            .from('payout_requests')\n            .insert([\n                {\n                    freelancer_id: userId,\n                    amount,\n                    status: 'pending',\n                    bank_account_number: bankDetails.accountNumber,\n                    bank_ifsc_code: bankDetails.ifscCode\n                }\n            ])\n            .select()\n            .single();\n\n        if (payoutError) throw payoutError;\n\n        // Update wallet balance\n        const newBalance = wallet.available_balance - amount;\n        const { error: updateError } = await supabase\n            .from('freelancer_wallets')\n            .update({ available_balance: newBalance })\n            .eq('freelancer_id', userId);\n\n        if (updateError) {\n            // If wallet update fails, delete the payout request\n            await supabase\n                .from('payout_requests')\n                .delete()\n                .eq('id', payout.id);\n            throw updateError;\n        }\n\n        // Send notification\n        await notificationsService.sendNotification(\n            userId,\n            `Payout request of $${amount.toFixed(2)} has been submitted and is being processed.`,\n            'payout'\n        );\n\n        return payout;\n    },\n\n    // Get payment history\n    async getPaymentHistory(userId: string) {\n        const { data: user, error: userError } = await supabase\n            .from('profiles')\n            .select('role')\n            .eq('id', userId)\n            .single();\n\n        if (userError || !user) {\n            throw new Error('User not found');\n        }\n\n        let query = supabase\n            .from('payments')\n            .select(`\n                id,\n                amount,\n                status,\n                payment_type,\n                created_at,\n                contract:contracts!inner(\n                    title,\n                    client:client_profiles!inner(\n                        company_name\n                    ),\n                    freelancer:freelancer_profiles!inner(\n                        full_name\n                    )\n                )\n            `)\n            .order('created_at', { ascending: false });\n\n        // Filter based on user role\n        if (user.role === 'freelancer') {\n            query = query.eq('contract.freelancer_id', userId);\n        } else if (user.role === 'client') {\n            query = query.eq('contract.client_id', userId);\n        }\n\n        const { data: payments, error } = await query as { data: PaymentHistoryItem[] | null; error: any };\n\n        if (error) {\n            console.error('Error fetching payment history:', error);\n            throw error;\n        }\n\n        return payments || [];\n    }\n}; \n// Add default export\nexport default paymentService;\n"],"names":["notificationsService","userId","message","type","error","supabase","paymentService","contractId","amount","paymentType","paymentLink","apiUrl","requestBody","startTime","response","errorMessage","errorData","responseData","payment_link","link","contract","contractError","validContract","paymentId","cashfreePaymentId","payment","fetchError","updateError","platformFee","freelancerAmount","wallet","walletFetchError","newBalance","totalEarned","walletUpdateError","bankDetails","walletError","payout","payoutError","user","userError","query","payments"],"mappings":"qEAEO,MAAMA,EAAuB,CAChC,MAAM,iBAAiBC,EAAgBC,EAAiBC,EAA4B,CAC5E,GAAA,CACM,KAAA,CAAE,MAAAC,GAAU,MAAMC,EACnB,KAAK,eAAe,EACpB,OAAO,CACJ,QAASJ,EACT,QAAAC,EACA,KAAAC,EACA,KAAM,EAAA,CACT,EACL,GAAIC,EAAa,MAAAA,EACV,MAAA,CAAE,QAAS,UACbA,EAAO,CACJ,cAAA,MAAM,8BAA+BA,CAAK,EAC5CA,CACV,CACJ,CACJ,ECgBME,EAAiB,CAEnB,MAAM,cAAcC,EAAoBC,EAAgBC,EAAyC,CAC7F,QAAQ,IAAI,mDAAoD,CAAE,WAAAF,EAAY,OAAAC,EAAQ,YAAAC,EAAa,EAC/F,IAAAC,EAEA,GAAA,CAEQ,QAAA,IAAI,iDAAkD,EAAK,EAGnE,MAAMC,EAAS,gBACP,QAAA,IAAI,kCAAmCA,CAAM,EAE7C,QAAA,IAAI,oDAAqDA,CAAM,EAEvE,MAAMC,EAAc,CAChB,WAAAL,EACA,OAAQ,OAAOC,CAAM,EACrB,YAAAC,CAAA,EAGJ,QAAQ,IAAI,uCAAwC,KAAK,UAAUG,EAAa,KAAM,CAAC,CAAC,EAElF,MAAAC,EAAY,KAAK,MACvB,QAAQ,IAAI,+CAAgD,IAAI,KAAK,EAAE,aAAa,EAC5E,QAAA,IAAI,oCAAqCF,CAAM,EAEnD,GAAA,CACM,MAAAG,EAAW,MAAM,MAAMH,EAAQ,CACjC,OAAQ,OAER,QAAS,CACL,eAAgB,mBAChB,OAAU,kBACd,EACA,KAAM,KAAK,UAAU,CACjB,WAAAJ,EACA,OAAQ,OAAOC,CAAM,EACrB,YAAAC,CAAA,CACH,EAED,YAAa,aAAA,CAChB,EAEG,GAAA,CAACK,EAAS,GAAI,CACV,IAAAC,EAAe,uBAAuBD,EAAS,MAAM,GACrD,GAAA,CACM,MAAAE,EAAY,MAAMF,EAAS,OACjCC,EAAeC,EAAU,SAAWA,EAAU,OAAS,KAAK,UAAUA,CAAS,OACvE,CAGRD,EADa,MAAMD,EAAS,QACLA,EAAS,YAAc,uBAAuBA,EAAS,MAAM,EACxF,CACA,cAAQ,MAAM,gDAAiD,CAC3D,OAAQA,EAAS,OACjB,WAAYA,EAAS,WACrB,IAAKA,EAAS,IACd,MAAOC,CAAA,CACV,EACK,IAAI,MAAMA,CAAY,CAChC,CAEM,MAAAE,EAAe,MAAMH,EAAS,OAEhC,GAAA,CAACG,EAAa,MAAQ,CAACA,EAAa,cAAgB,CAACA,EAAa,YAC5D,MAAA,IAAI,MAAM,sCAAsC,EAGlD,QAAA,IAAI,gDAAiDH,EAAS,MAAM,EACpE,QAAA,IAAI,qDAAsDG,CAAY,EAE9E,KAAM,CAAE,aAAAC,EAAc,YAAAR,CAAAA,EAAgBO,EAChCE,EAAOF,EAAa,MAAQC,GAAgBR,EAClD,GAAI,CAACS,EACK,MAAA,IAAI,MAAM,0CAA0C,EAEvD,OAAAA,QAEFf,EAAO,CACJ,QAAA,MAAM,oCAAqCA,CAAK,EACpDA,aAAiB,WACjB,QAAQ,MAAM,qHAAqH,EAC3H,QAAA,MAAM,wEAAyEO,CAAM,GACtFP,aAAiB,OAEhB,QAAA,MAAM,gCAAiCA,EAAM,KAAK,EAG9D,MAAMW,EAAeX,aAAiB,MAAQA,EAAM,QAAU,yBAC9D,MAAM,IAAI,MAAM,4BAA4BW,CAAY,EAAE,CAC9D,CAGA,KAAM,CAAE,KAAMK,EAAU,MAAOC,CAAc,EAAI,MAAMhB,EAClD,KAAK,WAAW,EAChB,OAAO,qCAAqC,EAC5C,GAAG,KAAME,CAAU,EACnB,SAEL,GAAIc,EACQ,cAAA,MAAM,2BAA4BA,CAAa,EACjD,IAAI,MAAM,kCAAkC,EAGtD,GAAI,CAACD,EACK,MAAA,IAAI,MAAM,oBAAoB,EAGxC,MAAME,EAAgBF,EAGlB,GAAA,CACA,MAAMpB,EAAqB,iBACvBsB,EAAc,UACd,uBAAuBd,CAAM,kBAAkBc,EAAc,KAAK,IAClE,SAAA,EAGJ,MAAMtB,EAAqB,iBACvBsB,EAAc,cACd,uBAAuBd,CAAM,8CAA8Cc,EAAc,KAAK,IAC9F,SAAA,QAEClB,EAAO,CACJ,QAAA,MAAM,+BAAgCA,CAAK,CAEvD,CAEO,OAAAM,QACFN,EAAO,CACJ,cAAA,MAAM,0BAA2BA,CAAK,EACxCA,CACV,CACJ,EAGA,MAAM,qBAAqBmB,EAAmBC,EAA2B,CACrE,KAAM,CAAE,KAAMC,EAAS,MAAOC,CAAW,EAAI,MAAMrB,EAC9C,KAAK,UAAU,EACf,OAAO,0EAA0E,EACjF,GAAG,KAAMkB,CAAS,EAClB,SAED,GAAAG,GAAc,CAACD,EACP,cAAA,MAAM,0BAA2BC,CAAU,EAC7C,IAAI,MAAM,oCAAoC,EAIlD,KAAA,CAAE,MAAOC,GAAgB,MAAMtB,EAChC,KAAK,UAAU,EACf,OAAO,CACJ,OAAQ,OACR,oBAAqBmB,EACrB,QAAS,IAAI,KAAK,EAAE,YAAY,CACnC,CAAA,EACA,GAAG,KAAMD,CAAS,EAEvB,GAAII,EAAmB,MAAAA,EAGjB,MAAAC,EAAcH,EAAQ,OAAS,GAC/BI,EAAmBJ,EAAQ,OAASG,EAGpC,CAAE,KAAME,EAAQ,MAAOC,GAAqB,MAAM1B,EACnD,KAAK,oBAAoB,EACzB,OAAO,iCAAiC,EACxC,GAAG,gBAAiBoB,EAAQ,SAAS,aAAa,EAClD,SAED,GAAAM,GAAoBA,EAAiB,OAAS,WACtC,cAAA,MAAM,yBAA0BA,CAAgB,EAClDA,EAGJ,MAAAC,IAAcF,GAAA,YAAAA,EAAQ,oBAAqB,GAAKD,EAChDI,IAAeH,GAAA,YAAAA,EAAQ,eAAgB,GAAKD,EAE5C,CAAE,MAAOK,GAAsB,MAAM7B,EACtC,KAAK,oBAAoB,EACzB,OAAO,CACJ,cAAeoB,EAAQ,SAAS,cAChC,kBAAmBO,EACnB,aAAcC,CAAA,EACf,CACC,WAAY,eAAA,CACf,EAEL,GAAIC,EACQ,cAAA,MAAM,yBAA0BA,CAAiB,EACnDA,EAiBN,GAbJ,MAAMlC,EAAqB,iBACvByB,EAAQ,SAAS,cACjB,eAAeA,EAAQ,OAAO,QAAQ,CAAC,CAAC,kDAAkDI,EAAiB,QAAQ,CAAC,CAAC,IACrH,SAAA,EAGJ,MAAM7B,EAAqB,iBACvByB,EAAQ,SAAS,UACjB,eAAeA,EAAQ,OAAO,QAAQ,CAAC,CAAC,oCACxC,SAAA,EAIAA,EAAQ,eAAiB,aAAc,CACjC,KAAA,CAAE,MAAOJ,GAAkB,MAAMhB,EAClC,KAAK,WAAW,EAChB,OAAO,CACJ,OAAQ,YACR,aAAc,IAAI,KAAK,EAAE,YAAY,CACxC,CAAA,EACA,GAAG,KAAMoB,EAAQ,WAAW,EAEjC,GAAIJ,EACQ,cAAA,MAAM,kCAAmCA,CAAa,EACxDA,CAEd,CACJ,EAGA,MAAM,cAAcpB,EAAgBO,EAAgB2B,EAA0D,CAE1G,KAAM,CAAE,KAAML,EAAQ,MAAOM,CAAY,EAAI,MAAM/B,EAC9C,KAAK,oBAAoB,EACzB,OAAO,mBAAmB,EAC1B,GAAG,gBAAiBJ,CAAM,EAC1B,SAEL,GAAImC,EAAmB,MAAAA,EACvB,GAAI,CAACN,GAAUA,EAAO,kBAAoBtB,EAChC,MAAA,IAAI,MAAM,+CAA+C,EAI7D,KAAA,CAAE,KAAM6B,EAAQ,MAAOC,CAAA,EAAgB,MAAMjC,EAC9C,KAAK,iBAAiB,EACtB,OAAO,CACJ,CACI,cAAeJ,EACf,OAAAO,EACA,OAAQ,UACR,oBAAqB2B,EAAY,cACjC,eAAgBA,EAAY,QAChC,CAAA,CACH,EACA,SACA,SAEL,GAAIG,EAAmB,MAAAA,EAGjB,MAAAN,EAAaF,EAAO,kBAAoBtB,EACxC,CAAE,MAAOmB,CAAA,EAAgB,MAAMtB,EAChC,KAAK,oBAAoB,EACzB,OAAO,CAAE,kBAAmB2B,CAAY,CAAA,EACxC,GAAG,gBAAiB/B,CAAM,EAE/B,GAAI0B,EAEM,YAAAtB,EACD,KAAK,iBAAiB,EACtB,SACA,GAAG,KAAMgC,EAAO,EAAE,EACjBV,EAIV,aAAM3B,EAAqB,iBACvBC,EACA,sBAAsBO,EAAO,QAAQ,CAAC,CAAC,8CACvC,QAAA,EAGG6B,CACX,EAGA,MAAM,kBAAkBpC,EAAgB,CACpC,KAAM,CAAE,KAAMsC,EAAM,MAAOC,CAAU,EAAI,MAAMnC,EAC1C,KAAK,UAAU,EACf,OAAO,MAAM,EACb,GAAG,KAAMJ,CAAM,EACf,SAED,GAAAuC,GAAa,CAACD,EACR,MAAA,IAAI,MAAM,gBAAgB,EAGpC,IAAIE,EAAQpC,EACP,KAAK,UAAU,EACf,OAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,aAeP,EACA,MAAM,aAAc,CAAE,UAAW,GAAO,EAGzCkC,EAAK,OAAS,aACNE,EAAAA,EAAM,GAAG,yBAA0BxC,CAAM,EAC1CsC,EAAK,OAAS,WACbE,EAAAA,EAAM,GAAG,qBAAsBxC,CAAM,GAGjD,KAAM,CAAE,KAAMyC,EAAU,MAAAtC,GAAU,MAAMqC,EAExC,GAAIrC,EACQ,cAAA,MAAM,kCAAmCA,CAAK,EAChDA,EAGV,OAAOsC,GAAY,CAAA,CACvB,CACJ"}